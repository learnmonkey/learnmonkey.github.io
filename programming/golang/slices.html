---
title: Go Slices
permalink: /programming/golang/slices/
layout: golang
---

<h1>Go Slices</h1>

<section>
    <h2>What are Slices?</h2>
    <p>Slices are arrays that can grow or shrink in size. However, slice elements must have the same data type, like arrays.</p>
</section>

<section>
    <h2>Declaring a Slice</h2>
    <p>First of all, we can declare a completely empty slice like this: </p>
    <pre><code class="language-go">
empty_slice := []<i>datatype</i>
    </code></pre>
    <p>If we want to initialize some values, we can do it like this: </p>
    <pre><code class="language-go">
non_empty_slice := []<i>datatype</i>{<i>values</i>}
    </code></pre>
    <p>The values are seperated by commas. For example: </p>
    <pre><code class="language-go">
cities := []string{"New York", "San Francisco", "Los Angeles", "Chicago"}
nums := []int{6,3,6,8,26,34,432}
    </code></pre>
</section>

<section>
    <h2>Making a Slice From an Array</h2>
    <p>To make a slice from an array, we have to specify the start and end indices for the slice: </p>
    <pre><code class="language-go">
var example_array = [<i>length</i>]<i>datatype</i>{<i>values</i>} // make an array
example_slice := example_array[<i>start</i>:<i>end</i>] // make a slice from that array
    </code></pre>
    <p>For example: </p>
    <pre><code class="language-go">
arr1 := [5]string{"Chimpanzee", "Capuchin", "Gorilla", "Macaque", "Orangutan", "Bonobo"}
var slice1 = arr1[1:4]
fmt.Println(slice1)
    </code></pre>
    <p>The above code returns: </p>
    <pre><samp>
[Capuchin Gorilla Macaque Orangutan]
    </samp></pre>
</section>

<section>
    <h2>Accessing a Slice Element</h2>
    <p>To access and set slice elements, we use slice indices. Slice indices start at zero for the first element and the index goes up by one for every element we go. For example, the element with slice index 2 is the third element and the element with slice index 4 is the fifth element.</p>
    <p>To access slice elements, we type: </p>
    <code class="language-go"><i>slice</i>[<i>index</i>]</code>
    <p>We replace <code><i>slice</i></code> with the name of the slice variable and <code><i>index</i></code> with the index of the element. For example:</p>
    <pre><code class="language-go">
websites := []string{"GitHub", "Wikipedia", "Learnmonkey", "Twitter", "Gmail", "Stack Overflow"}
fmt.Println(websites[2])
fmt.Println(websites[5])
fmt.Println(websites[0])
fmt.Println(websites[1])
    </code></pre>
</section>

<section>
    <h2>Appending an Element to a Slice</h2>
    <p>The <code>append</code> function is used to append elements to a slice:</p>
    <pre><code class="language-go">
slice_name = append(slice_name, element1, element2, ...)
    </code></pre>
    <small><i class="fas fa-exclamation-circle"></i>Remember that the <code>append</code> function returns another array. It does not actually append the element to the slice unless we set the slice to the output of it.</small>
</section>

<section>
    <h2>Getting the Length of a Slice</h2>
    <p>To get the length of a slice, we can use two functions: <code>len</code> and <code>cap</code>. The <code>len</code> function returns how many elements are actually in the slice. For example: </p>
    <pre><code class="language-go">
countries := []string{"France", "Germany", "Italy", "United States", "Canada", "China", "Mexico"}
fmt.Println(len(countries))
    </code></pre>
    <p>The above code returns: </p>
    <pre><samp>
7
    </samp></pre>
    <p>However, see what happens if we use the <code>cap</code> function: </p>
    <pre><code class="language-go">
fmt.Println(cap(countries))
    </code></pre>
    <p>The code returns: </p>
    <pre><samp>
7
    </samp></pre>
    <p>Hmm. Same thing. But see what happens when we append an element: </p>
    <pre><code class="language-go">
countries = append(countries, "Brazil")
fmt.Println(len(countries))
fmt.Println(cap(countries))
    </code></pre>
    <p>Now, we get: </p>
    <pre><samp>
8
14
    </samp></pre>
    <p>The reason this is happening is because <code>len</code> returns the number of elements in the slice, but <code>cap</code> returns the equivalent amount of memory the actual slice is using.</p>
</section>

<section>
    <h2>Appending a Slice to a Slice</h2>
    <p>Appending a slice to a slice also uses the <code>append</code> function:</p>
    <pre><code class="language-go">
slice3 = append(slice1, slice2...) // you can add as many slices as you want
    </code></pre>
    <p>In the above example, we are appending the <code>slice1</code> and <code>slice2</code> slices to the <code>slice3</code> slice.</p>
    <small><i class="fas fa-exclamation-circle"></i>The <code>...</code> is required! If you don't add it, Go will think that you are adding the slices as elements.</small>
</section>

<section>
    <h2>Nested Slices</h2>
    <p>We can put slices inside of slices, just as we could with any other data type. The only difference is that the code is uglier: </p>
    <pre><code class="language-go">
mySlice := [][]int{
    {0, 1, 2, 3},
    {4, 5, 6, 7},
}
    </code></pre>
    <p>Nested slices can represent tables and matrices.</p>
</section>